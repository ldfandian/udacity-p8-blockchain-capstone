const truffleAssert = require('../../node_modules/truffle-assertions');
var proofConfigLib = require('./proofConfig.js');

// define a variable to import the <Verifier> or <renamedVerifier> solidity contract generated by Zokrates
var SolnSquareVerifier = artifacts.require('SolnSquareVerifier');
var ZokratesSquareVerifier = artifacts.require('Verifier');

// Test if a new solution can be added for contract - SolnSquareVerifier
// Test if an ERC721 token can be minted for contract - SolnSquareVerifier
contract('TestSolnSquareVerifier', accounts => {

    const account_one = accounts[0];
    const account_two = accounts[1];
    const account_three = accounts[2];

    const TestVSSVContractName = 'TestSolnSquareVerifierContract';
    const TestVSSVContractSymbol = 'TSSV';

    var proofConfig;

    describe('test zokrates square verifier', function () {
        beforeEach(async function () {
            let verifierContract = await ZokratesSquareVerifier.new({ from: account_one });
            this.contract = await SolnSquareVerifier.new(
                verifierContract.address, TestVSSVContractName, TestVSSVContractSymbol, { from: account_one });
            proofConfig = await proofConfigLib.config();
        })

        it('Test if a new solution can be added for contract - positive', async function () {
            // add solution: 9
            {
                let solution9 = await this.contract.addSolution(
                    proofConfig.PROOF_9.a, proofConfig.PROOF_9.b, proofConfig.PROOF_9.c, proofConfig.PROOF_9.inputs, { from: account_one });
                truffleAssert.eventEmitted(solution9, 'SolutionAdded', (ev) => {
                    return expect(ev.to).equal(account_one);
                });
            }

            // add solution: 16
            {
                let solution16 = await this.contract.addSolution(
                    proofConfig.PROOF_16.a, proofConfig.PROOF_16.b, proofConfig.PROOF_16.c, proofConfig.PROOF_16.inputs, { from: account_two });
                truffleAssert.eventEmitted(solution16, 'SolutionAdded', (ev) => {
                    return expect(ev.to).equal(account_two);
                });
            }
        })

        it('Test if a new solution can be added for contract - negative', async function () {
            // failed solution verification
            {
                let badInputs = [proofConfig.PROOF_9.inputs[0], proofConfig.PROOF_16.inputs[1]];
                truffleAssert.reverts(
                    this.contract.addSolution(
                        proofConfig.PROOF_16.a, proofConfig.PROOF_16.b, proofConfig.PROOF_16.c, badInputs, { from: account_two }),
                    'verification of the solution failed');
            }

            // duplicated solution add ops
            {
                let solution9 = await this.contract.addSolution(
                    proofConfig.PROOF_9.a, proofConfig.PROOF_9.b, proofConfig.PROOF_9.c, proofConfig.PROOF_9.inputs, { from: account_one });
                truffleAssert.eventEmitted(solution9, 'SolutionAdded', (ev) => {
                    return expect(ev.to).equal(account_one);
                });

                truffleAssert.reverts(
                    this.contract.addSolution(
                        proofConfig.PROOF_9.a, proofConfig.PROOF_9.b, proofConfig.PROOF_9.c, proofConfig.PROOF_9.inputs, { from: account_one }),
                    'solution has been added');
            }
        })

        it('Test if an ERC721 token can be minted for contract - positive', async function () { 
            // mint 9
            {
                assert.equal(await this.contract.balanceOf(account_one), 0);

                let solution9 = await this.contract.addSolution(
                    proofConfig.PROOF_9.a, proofConfig.PROOF_9.b, proofConfig.PROOF_9.c, proofConfig.PROOF_9.inputs, { from: account_one });
                truffleAssert.eventEmitted(solution9, 'SolutionAdded', (ev) => {
                    return expect(ev.to).equal(account_one);
                });
                let mint9 = await this.contract.mintNewNFT(proofConfig.PROOF_9.inputs, account_one, { from: account_one });
                truffleAssert.eventEmitted(mint9, 'SolutionMinted', (ev) => {
                    return expect(ev.to).equal(account_one);
                });

                assert.equal(await this.contract.balanceOf(account_one), 1);
            }

            // mint 16
            {
                assert.equal(await this.contract.balanceOf(account_one), 1);
                assert.equal(await this.contract.balanceOf(account_two), 0);

                let solution16 = await this.contract.addSolution(
                    proofConfig.PROOF_16.a, proofConfig.PROOF_16.b, proofConfig.PROOF_16.c, proofConfig.PROOF_16.inputs, { from: account_two });
                truffleAssert.eventEmitted(solution16, 'SolutionAdded', (ev) => {
                    return expect(ev.to).equal(account_two);
                });
                let mint16 = await this.contract.mintNewNFT(proofConfig.PROOF_16.inputs, account_one, { from: account_two });
                truffleAssert.eventEmitted(mint16, 'SolutionMinted', (ev) => {
                    return expect(ev.to).equal(account_one);
                });

                assert.equal(await this.contract.balanceOf(account_one), 2);
                assert.equal(await this.contract.balanceOf(account_two), 0);
            }

            // mint 25
            {
                assert.equal(await this.contract.balanceOf(account_two), 0);
                assert.equal(await this.contract.balanceOf(account_three), 0);

                let solution25 = await this.contract.addSolution(
                    proofConfig.PROOF_25.a, proofConfig.PROOF_25.b, proofConfig.PROOF_25.c, proofConfig.PROOF_25.inputs, { from: account_two });
                truffleAssert.eventEmitted(solution25, 'SolutionAdded', (ev) => {
                    return expect(ev.to).equal(account_two);
                });
                let mint25 = await this.contract.mintNewNFT(proofConfig.PROOF_25.inputs, account_three, { from: account_two });
                truffleAssert.eventEmitted(mint25, 'SolutionMinted', (ev) => {
                    return expect(ev.to).equal(account_three);
                });

                assert.equal(await this.contract.balanceOf(account_two), 0);
                assert.equal(await this.contract.balanceOf(account_three), 1);
            }
        })

        it('Test if an ERC721 token can be minted for contract - negative', async function () { 
            // solution does not exist
            {
                let badInputs = [proofConfig.PROOF_9.inputs[0], proofConfig.PROOF_16.inputs[1]];
                truffleAssert.reverts(
                    this.contract.mintNewNFT(badInputs, account_one, { from: account_one }),
                    'solution does not exist');
            }

            // -- prepare test environment: add solution 9
            {
                assert.equal(await this.contract.balanceOf(account_one), 0);
                let solution9 = await this.contract.addSolution(
                    proofConfig.PROOF_9.a, proofConfig.PROOF_9.b, proofConfig.PROOF_9.c, proofConfig.PROOF_9.inputs, { from: account_one });
                truffleAssert.eventEmitted(solution9, 'SolutionAdded', (ev) => {
                    return expect(ev.to).equal(account_one);
                });
            }

            // it is not your solution
            {
                truffleAssert.reverts(
                    this.contract.mintNewNFT(proofConfig.PROOF_9.inputs, account_one, { from: account_two }),
                    'it is not your solution');
            }

            // -- prepare test environment: mint 9
            {
                let mint9 = await this.contract.mintNewNFT(proofConfig.PROOF_9.inputs, account_one, { from: account_one });
                truffleAssert.eventEmitted(mint9, 'SolutionMinted', (ev) => {
                    return expect(ev.to).equal(account_one);
                });
                assert.equal(await this.contract.balanceOf(account_one), 1);
            }

            // solution has been minted
            {
                truffleAssert.reverts(
                    this.contract.mintNewNFT(proofConfig.PROOF_9.inputs, account_one, { from: account_one }),
                    'solution does not exist');
            }
        })
    });

})
